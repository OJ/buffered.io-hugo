---
categories:
- Functional Programming
- Haskell
- Project Euler
comments: true
date: 2008-03-18T00:00:00Z
tags:
- functional
- Haskell
- programming
- Project Euler
title: 'Project Euler #2'
---

<strong>WARNING!</strong> This post contains a spoiler for Problem #2 listed at <a href="http://projecteuler.net/" title="Project Euler">Project Euler</a>. Do not read the rest of this post if you're planning to attempt to solve the problem yourself.

<!--more-->

<a href="http://projecteuler.net/index.php?section=problems&id=2">Problem #2</a> in the series is a little step up from the previous question, and involves a little more thought:<blockquote><p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

Find the sum of all the even-valued terms in the sequence which do not exceed four million.</p></blockquote>

Here is my Haskell source that generates the required answer:
```
-- Infinite list of Fibonacci numbers
fibs :: [Integer]
fibs = 1 : 2 : [ n | n <- zipWith (+) (tail fibs) fibs ]

-- function that sums even values of fibs up to a number
sumEvenFibsTo :: Integer -> Integer
sumEvenFibsTo i = sum [ n | n <- takeWhile (<i) fibs, ((mod n 2) == 0)]

-- main - the programs entry point when compiled
main :: IO ()
main = print $ sumEvenFibsTo 4000000
```

As we can see it's a little more complicated than the previous question, but isn't too difficult either. I won't go into the same level of detail as I did before when explaining the solution as I think most of it is obvious. Instead I'll just explain the bits that are a little convoluted:<ol><li><strong>tail</strong> - returns the list with the first item (the <em>head</em>) removed.</li><li><strong>zipWith</strong> - this is a built-in function that is part of <a href="http://www.haskell.org/hoogle/hoodoc.cgi?module=Prelude&mode=module" title="Prelude">Prelude</a>. It takes two lists (the last two parameters) and iterates through each at the same time. For each pair of items (one from each list) it applies the given function.</li><li><strong>zipWith (+) (tail fibs) fibs</strong> - create another list which is made up of the sum of each item in fibs with each item in the tail of fibs.</li><li><strong>takeWhile</strong> - takes from the head of the list until the value meets a given condition.</li><li><strong>print</strong> - displays a value on the screen.</li><li><strong>$</strong> - this is used as a way of separating function calls. Haskell is aggressive with its argument passing, and hence lots of parenthesis need to be used to make sure it's obvious what things are associated with each other. the <em>$</em> operator is just another way of doing the same thing without using parenthesis.</li></ol>
Again it's a neat solution. Nice and concise. The kicker here is the definition of <em>fibs</em>, the infinite recursive array. In Haskell, you can define a function using references to itself. Lists are just the same, as they're not evaluated until run-time. So you can define a list with no bounds, and at run-time you have the responsibility of making sure you don't try and parse the entire structure. This is where the <em>takeWhile</em> function comes in to our solution, we only take values while they're less than 4,000,000. Because we know that the Fibonacci sequence always increases in size, we know that it will eventually end.

I'll leave it to you to get your head around the recursive definition. If you want more clarification, just post a comment. Enjoy :)
